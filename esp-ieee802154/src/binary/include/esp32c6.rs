/* automatically generated by rust-bindgen 0.65.1 */

#![allow(dead_code)]
#![allow(improper_ctypes)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.1.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_NOT_FINISHED: u32 = 268;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const ESP_ERR_HW_CRYPTO_BASE: u32 = 49152;
pub const ESP_ERR_MEMPROT_BASE: u32 = 53248;
pub const ESP_CAL_DATA_CHECK_FAIL: u32 = 1;
pub const ESP_COEX_BLE_ST_MESH_CONFIG: u32 = 8;
pub const ESP_COEX_BLE_ST_MESH_TRAFFIC: u32 = 16;
pub const ESP_COEX_BLE_ST_MESH_STANDBY: u32 = 32;
pub const ESP_COEX_BT_ST_A2DP_STREAMING: u32 = 16;
pub const ESP_COEX_BT_ST_A2DP_PAUSED: u32 = 32;
pub const COEX_ADAPTER_VERSION: u32 = 2;
pub const COEX_ADAPTER_MAGIC: u32 = 3735928495;
pub const COEX_ADAPTER_FUNCS_TIME_BLOCKING: u32 = 4294967295;
pub type __int8_t = crate::binary::c_types::c_schar;
pub type __uint8_t = crate::binary::c_types::c_uchar;
pub type __int16_t = crate::binary::c_types::c_short;
pub type __uint16_t = crate::binary::c_types::c_ushort;
pub type __int32_t = crate::binary::c_types::c_int;
pub type __uint32_t = crate::binary::c_types::c_uint;
pub type __int64_t = crate::binary::c_types::c_longlong;
pub type __uint64_t = crate::binary::c_types::c_ulonglong;
pub type __int_least8_t = crate::binary::c_types::c_schar;
pub type __uint_least8_t = crate::binary::c_types::c_uchar;
pub type __int_least16_t = crate::binary::c_types::c_short;
pub type __uint_least16_t = crate::binary::c_types::c_ushort;
pub type __int_least32_t = crate::binary::c_types::c_int;
pub type __uint_least32_t = crate::binary::c_types::c_uint;
pub type __int_least64_t = crate::binary::c_types::c_longlong;
pub type __uint_least64_t = crate::binary::c_types::c_ulonglong;
pub type __intmax_t = crate::binary::c_types::c_long;
pub type __uintmax_t = crate::binary::c_types::c_ulong;
pub type __intptr_t = crate::binary::c_types::c_long;
pub type __uintptr_t = crate::binary::c_types::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::binary::c_types::c_schar;
pub type uint_fast8_t = crate::binary::c_types::c_uchar;
pub type int_fast16_t = crate::binary::c_types::c_short;
pub type uint_fast16_t = crate::binary::c_types::c_ushort;
pub type int_fast32_t = crate::binary::c_types::c_int;
pub type uint_fast32_t = crate::binary::c_types::c_uint;
pub type int_fast64_t = crate::binary::c_types::c_longlong;
pub type uint_fast64_t = crate::binary::c_types::c_ulonglong;
pub type wchar_t = crate::binary::c_types::c_int;
pub type max_align_t = u128;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = crate::binary::c_types::c_int;
pub type __blkcnt_t = crate::binary::c_types::c_long;
pub type __blksize_t = crate::binary::c_types::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = crate::binary::c_types::c_long;
pub type __pid_t = crate::binary::c_types::c_int;
pub type __dev_t = crate::binary::c_types::c_short;
pub type __uid_t = crate::binary::c_types::c_ushort;
pub type __gid_t = crate::binary::c_types::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = crate::binary::c_types::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = crate::binary::c_types::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = crate::binary::c_types::c_long;
pub type _fpos_t = crate::binary::c_types::c_long;
pub type __size_t = crate::binary::c_types::c_ulong;
pub type _ssize_t = crate::binary::c_types::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: crate::binary::c_types::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [crate::binary::c_types::c_uchar; 4usize],
}
pub type _iconv_t = *mut crate::binary::c_types::c_void;
pub type __clock_t = crate::binary::c_types::c_ulong;
pub type __time_t = crate::binary::c_types::c_long;
pub type __clockid_t = crate::binary::c_types::c_ulong;
pub type __timer_t = crate::binary::c_types::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = crate::binary::c_types::c_int;
pub type __nlink_t = crate::binary::c_types::c_ushort;
pub type __suseconds_t = crate::binary::c_types::c_long;
pub type __useconds_t = crate::binary::c_types::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = crate::binary::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: crate::binary::c_types::c_int,
    pub _maxwds: crate::binary::c_types::c_int,
    pub _sign: crate::binary::c_types::c_int,
    pub _wds: crate::binary::c_types::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __tm {
    pub __tm_sec: crate::binary::c_types::c_int,
    pub __tm_min: crate::binary::c_types::c_int,
    pub __tm_hour: crate::binary::c_types::c_int,
    pub __tm_mday: crate::binary::c_types::c_int,
    pub __tm_mon: crate::binary::c_types::c_int,
    pub __tm_year: crate::binary::c_types::c_int,
    pub __tm_wday: crate::binary::c_types::c_int,
    pub __tm_yday: crate::binary::c_types::c_int,
    pub __tm_isdst: crate::binary::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut crate::binary::c_types::c_void; 32usize],
    pub _dso_handle: [*mut crate::binary::c_types::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: crate::binary::c_types::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut crate::binary::c_types::c_uchar,
    pub _size: crate::binary::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut crate::binary::c_types::c_uchar,
    pub _r: crate::binary::c_types::c_int,
    pub _w: crate::binary::c_types::c_int,
    pub _flags: crate::binary::c_types::c_short,
    pub _file: crate::binary::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::binary::c_types::c_int,
    pub _data: *mut _reent,
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut crate::binary::c_types::c_uchar,
    pub _r: crate::binary::c_types::c_int,
    pub _w: crate::binary::c_types::c_int,
    pub _flags: crate::binary::c_types::c_short,
    pub _file: crate::binary::c_types::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: crate::binary::c_types::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut crate::binary::c_types::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::binary::c_types::c_void,
            arg3: *mut crate::binary::c_types::c_char,
            arg4: crate::binary::c_types::c_int,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::binary::c_types::c_void,
            arg3: *const crate::binary::c_types::c_char,
            arg4: crate::binary::c_types::c_int,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::binary::c_types::c_void,
            arg3: _fpos_t,
            arg4: crate::binary::c_types::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut crate::binary::c_types::c_void,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut crate::binary::c_types::c_uchar,
    pub _ur: crate::binary::c_types::c_int,
    pub _ubuf: [crate::binary::c_types::c_uchar; 3usize],
    pub _nbuf: [crate::binary::c_types::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: crate::binary::c_types::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: crate::binary::c_types::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: crate::binary::c_types::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rand48 {
    pub _seed: [crate::binary::c_types::c_ushort; 3usize],
    pub _mult: [crate::binary::c_types::c_ushort; 3usize],
    pub _add: crate::binary::c_types::c_ushort,
    pub _rand_next: crate::binary::c_types::c_ulonglong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: crate::binary::c_types::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut crate::binary::c_types::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [crate::binary::c_types::c_char; 8usize],
    pub _getdate_err: crate::binary::c_types::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: crate::binary::c_types::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: crate::binary::c_types::c_int,
    pub _emergency: *mut crate::binary::c_types::c_char,
    pub __sdidinit: crate::binary::c_types::c_int,
    pub _unspecified_locale_info: crate::binary::c_types::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: crate::binary::c_types::c_int,
    pub _cvtlen: crate::binary::c_types::c_int,
    pub _cvtbuf: *mut crate::binary::c_types::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut crate::binary::c_types::c_char,
    pub _sig_func:
        *mut ::core::option::Option<unsafe extern "C" fn(arg1: crate::binary::c_types::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut crate::binary::c_types::c_char,
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub fn __assert(
        arg1: *const crate::binary::c_types::c_char,
        arg2: crate::binary::c_types::c_int,
        arg3: *const crate::binary::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const crate::binary::c_types::c_char,
        arg2: crate::binary::c_types::c_int,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *const crate::binary::c_types::c_char,
    ) -> !;
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = crate::binary::c_types::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = crate::binary::c_types::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: crate::binary::c_types::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = crate::binary::c_types::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 1usize],
}
extern "C" {
    pub fn select(
        __n: crate::binary::c_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn pselect(
        __n: crate::binary::c_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> crate::binary::c_types::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = crate::binary::c_types::c_uchar;
pub type u_short = crate::binary::c_types::c_ushort;
pub type u_int = crate::binary::c_types::c_uint;
pub type u_long = crate::binary::c_types::c_ulong;
pub type ushort = crate::binary::c_types::c_ushort;
pub type uint = crate::binary::c_types::c_uint;
pub type ulong = crate::binary::c_types::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = crate::binary::c_types::c_ulong;
pub type daddr_t = crate::binary::c_types::c_long;
pub type caddr_t = *mut crate::binary::c_types::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param {
    pub sched_priority: crate::binary::c_types::c_int,
}
extern "C" {
    pub fn sched_yield() -> crate::binary::c_types::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: crate::binary::c_types::c_int,
    pub stackaddr: *mut crate::binary::c_types::c_void,
    pub stacksize: crate::binary::c_types::c_int,
    pub contentionscope: crate::binary::c_types::c_int,
    pub inheritsched: crate::binary::c_types::c_int,
    pub schedpolicy: crate::binary::c_types::c_int,
    pub schedparam: sched_param,
    pub detachstate: crate::binary::c_types::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: crate::binary::c_types::c_int,
    pub recursive: crate::binary::c_types::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: crate::binary::c_types::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: crate::binary::c_types::c_int,
    pub init_executed: crate::binary::c_types::c_int,
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(
        arg1: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut crate::binary::c_types::c_char)
        -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut crate::binary::c_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
        arg4: usize,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn printf(
        arg1: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const crate::binary::c_types::c_char, ...)
        -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: crate::binary::c_types::c_int,
        arg3: *mut FILE,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn fputc(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fputs(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn getchar() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut crate::binary::c_types::c_char) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn putc(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn putchar(arg1: crate::binary::c_types::c_int) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn puts(arg1: *const crate::binary::c_types::c_char) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn ungetc(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut crate::binary::c_types::c_void,
        _size: crate::binary::c_types::c_ulong,
        _n: crate::binary::c_types::c_ulong,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const crate::binary::c_types::c_void,
        _size: crate::binary::c_types::c_ulong,
        _n: crate::binary::c_types::c_ulong,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_ulong;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: crate::binary::c_types::c_long,
        arg3: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn perror(arg1: *const crate::binary::c_types::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const crate::binary::c_types::c_char,
        _type: *const crate::binary::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn remove(arg1: *const crate::binary::c_types::c_char) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: crate::binary::c_types::c_ulong,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: crate::binary::c_types::c_ulong,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: crate::binary::c_types::c_int,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn iprintf(
        arg1: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn iscanf(
        arg1: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: usize,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *mut usize,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: crate::binary::c_types::c_int,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: usize,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fdopen(
        arg1: crate::binary::c_types::c_int,
        arg2: *const crate::binary::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn putw(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: crate::binary::c_types::c_int) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: crate::binary::c_types::c_int,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut crate::binary::c_types::c_void,
        arg2: usize,
        arg3: *const crate::binary::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        arg1: *mut *mut crate::binary::c_types::c_char,
        arg2: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: crate::binary::c_types::c_int,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: crate::binary::c_types::c_int,
        arg2: *const crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
        arg4: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::binary::c_types::c_char,
        ...
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::binary::c_types::c_char,
        ...
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *const crate::binary::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
        arg4: *mut FILE,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_void,
        arg3: usize,
        arg4: *const crate::binary::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: crate::binary::c_types::c_long,
        arg4: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::binary::c_types::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const crate::binary::c_types::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _putchar_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _puts_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const crate::binary::c_types::c_char,
        _new: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: usize,
        arg4: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: usize,
        arg4: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        ...
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::binary::c_types::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *mut usize,
        arg4: *const crate::binary::c_types::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: usize,
        arg4: *const crate::binary::c_types::c_char,
        arg5: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: usize,
        arg4: *const crate::binary::c_types::c_char,
        arg5: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *const crate::binary::c_types::c_char,
        arg4: *mut __va_list_tag,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut crate::binary::c_types::c_char,
        arg2: *mut usize,
        arg3: crate::binary::c_types::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut crate::binary::c_types::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut crate::binary::c_types::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const crate::binary::c_types::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: crate::binary::c_types::c_int,
        arg3: *mut FILE,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const crate::binary::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
                __buf: *mut crate::binary::c_types::c_char,
                __n: crate::binary::c_types::c_int,
            ) -> crate::binary::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
                __buf: *const crate::binary::c_types::c_char,
                __n: crate::binary::c_types::c_int,
            ) -> crate::binary::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
                __off: fpos_t,
                __whence: crate::binary::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
            ) -> crate::binary::c_types::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const crate::binary::c_types::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
                __buf: *mut crate::binary::c_types::c_char,
                __n: crate::binary::c_types::c_int,
            ) -> crate::binary::c_types::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
                __buf: *const crate::binary::c_types::c_char,
                __n: crate::binary::c_types::c_int,
            ) -> crate::binary::c_types::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
                __off: fpos_t,
                __whence: crate::binary::c_types::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut crate::binary::c_types::c_void,
            ) -> crate::binary::c_types::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: crate::binary::c_types::c_int,
    pub rem: crate::binary::c_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: crate::binary::c_types::c_long,
    pub rem: crate::binary::c_types::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: crate::binary::c_types::c_longlong,
    pub rem: crate::binary::c_types::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const crate::binary::c_types::c_void,
        arg2: *const crate::binary::c_types::c_void,
    ) -> crate::binary::c_types::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: crate::binary::c_types::c_int) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut crate::binary::c_types::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const crate::binary::c_types::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const crate::binary::c_types::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const crate::binary::c_types::c_char) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const crate::binary::c_types::c_char) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const crate::binary::c_types::c_void,
        __base: *const crate::binary::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn calloc(
        arg1: crate::binary::c_types::c_ulong,
        arg2: crate::binary::c_types::c_ulong,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn div(
        __numer: crate::binary::c_types::c_int,
        __denom: crate::binary::c_types::c_int,
    ) -> div_t;
}
extern "C" {
    pub fn exit(__status: crate::binary::c_types::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut crate::binary::c_types::c_void);
}
extern "C" {
    pub fn getenv(
        __string: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *mut crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut crate::binary::c_types::c_char,
        arg2: *const *mut crate::binary::c_types::c_char,
        arg3: *mut *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn labs(arg1: crate::binary::c_types::c_long) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn ldiv(
        __numer: crate::binary::c_types::c_long,
        __denom: crate::binary::c_types::c_long,
    ) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: crate::binary::c_types::c_ulong) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn mblen(
        arg1: *const crate::binary::c_types::c_char,
        arg2: usize,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const crate::binary::c_types::c_char,
        arg3: usize,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::binary::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wctomb(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: wchar_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const crate::binary::c_types::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const crate::binary::c_types::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: *const wchar_t,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(
        arg1: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut crate::binary::c_types::c_char) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut crate::binary::c_types::c_char,
        arg2: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut crate::binary::c_types::c_char)
        -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
        arg4: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut crate::binary::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut crate::binary::c_types::c_void,
        arg2: crate::binary::c_types::c_ulong,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut crate::binary::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn reallocf(
        arg1: *mut crate::binary::c_types::c_void,
        arg2: usize,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const crate::binary::c_types::c_char,
        resolved_path: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn rpmatch(
        response: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn srand(__seed: crate::binary::c_types::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_ulong;
}
extern "C" {
    pub fn system(__string: *const crate::binary::c_types::c_char)
        -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn a64l(__input: *const crate::binary::c_types::c_char) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn l64a(__input: crate::binary::c_types::c_long) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: crate::binary::c_types::c_long,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: crate::binary::c_types::c_int,
                arg2: *mut crate::binary::c_types::c_void,
            ),
        >,
        __arg: *mut crate::binary::c_types::c_void,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _Exit(__status: crate::binary::c_types::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut crate::binary::c_types::c_char) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const crate::binary::c_types::c_char,
        __value: *const crate::binary::c_types::c_char,
        __overwrite: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const crate::binary::c_types::c_char,
        __value: *const crate::binary::c_types::c_char,
        __overwrite: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: crate::binary::c_types::c_uint,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: crate::binary::c_types::c_int,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: crate::binary::c_types::c_uint,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut crate::binary::c_types::c_uint) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut crate::binary::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut crate::binary::c_types::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut crate::binary::c_types::c_ushort) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_ushort,
    ) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut crate::binary::c_types::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut crate::binary::c_types::c_ushort);
}
extern "C" {
    pub fn lrand48() -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn mrand48() -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut crate::binary::c_types::c_ushort) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_ushort,
    ) -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn seed48(
        arg1: *mut crate::binary::c_types::c_ushort,
    ) -> *mut crate::binary::c_types::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_ushort,
    ) -> *mut crate::binary::c_types::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: crate::binary::c_types::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: crate::binary::c_types::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: crate::binary::c_types::c_uint,
        arg2: *mut crate::binary::c_types::c_char,
        arg3: usize,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn random() -> crate::binary::c_types::c_long;
}
extern "C" {
    pub fn setstate(
        arg1: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn srandom(arg1: crate::binary::c_types::c_uint);
}
extern "C" {
    pub fn atoll(
        __nptr: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: crate::binary::c_types::c_longlong) -> crate::binary::c_types::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: crate::binary::c_types::c_longlong,
        __denom: crate::binary::c_types::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const crate::binary::c_types::c_char,
        __end_PTR: *mut *mut crate::binary::c_types::c_char,
        __base: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut crate::binary::c_types::c_void);
}
extern "C" {
    pub fn unsetenv(
        __string: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut crate::binary::c_types::c_void,
        arg2: usize,
        arg3: usize,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: crate::binary::c_types::c_int,
        arg4: crate::binary::c_types::c_int,
        arg5: *mut crate::binary::c_types::c_int,
        arg6: *mut crate::binary::c_types::c_int,
        arg7: *mut *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn _calloc_r(
        arg1: *mut _reent,
        arg2: usize,
        arg3: usize,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut crate::binary::c_types::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut crate::binary::c_types::c_void,
        arg3: usize,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut crate::binary::c_types::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *const crate::binary::c_types::c_char,
        arg3: crate::binary::c_types::c_uint,
        arg4: *const crate::binary::c_types::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}___bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut crate::binary::c_types::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut crate::binary::c_types::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::binary::c_types::c_void,
                arg2: *const crate::binary::c_types::c_void,
                arg3: *const crate::binary::c_types::c_void,
            ) -> crate::binary::c_types::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const crate::binary::c_types::c_char,
        arg3: *mut *mut crate::binary::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(
        arg1: *const crate::binary::c_types::c_char,
        arg2: *mut *mut crate::binary::c_types::c_char,
    ) -> u128;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: crate::binary::c_types::c_ulong,
        arg2: crate::binary::c_types::c_ulong,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: crate::binary::c_types::c_int);
}
pub type esp_err_t = crate::binary::c_types::c_int;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes\n\n This function finds the error code in a pre-generated lookup-table and\n returns its string representation.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const crate::binary::c_types::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes\n\n This function finds the error code in a pre-generated lookup-table of\n esp_err_t errors and returns its string representation. If the error code\n is not found then it is attempted to be found among system errors.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @param[out] buf buffer where the error message should be written\n @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte).\n @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut crate::binary::c_types::c_char,
        buflen: usize,
    ) -> *const crate::binary::c_types::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const crate::binary::c_types::c_char,
        line: crate::binary::c_types::c_int,
        function: *const crate::binary::c_types::c_char,
        expression: *const crate::binary::c_types::c_char,
    ) -> !;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const crate::binary::c_types::c_char,
        line: crate::binary::c_types::c_int,
        function: *const crate::binary::c_types::c_char,
        expression: *const crate::binary::c_types::c_char,
    );
}
#[doc = " @brief Structure holding PHY init parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_init_data_t {
    #[doc = "< opaque PHY initialization parameters"]
    pub params: [u8; 128usize],
}
#[doc = " @brief Opaque PHY calibration data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct esp_phy_calibration_data_t {
    #[doc = "< PHY version"]
    pub version: [u8; 4usize],
    #[doc = "< The MAC address of the station"]
    pub mac: [u8; 6usize],
    #[doc = "< calibration data"]
    pub opaque: [u8; 1894usize],
}
#[doc = "< Do part of RF calibration. This should be used after power-on reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_PARTIAL: esp_phy_calibration_mode_t = 0;
#[doc = "< Don't do any RF calibration. This mode is only suggested to be used after deep sleep reset."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_NONE: esp_phy_calibration_mode_t = 1;
#[doc = "< Do full RF calibration. Produces best results, but also consumes a lot of time and current. Suggested to be used once."]
pub const esp_phy_calibration_mode_t_PHY_RF_CAL_FULL: esp_phy_calibration_mode_t = 2;
#[doc = " @brief PHY calibration mode\n"]
pub type esp_phy_calibration_mode_t = crate::binary::c_types::c_uint;
extern "C" {
    #[doc = " @brief Get PHY init data\n\n If \"Use a partition to store PHY init data\" option is set in menuconfig,\n This function will load PHY init data from a partition. Otherwise,\n PHY init data will be compiled into the application itself, and this function\n will return a pointer to PHY init data located in read-only memory (DROM).\n\n If \"Use a partition to store PHY init data\" option is enabled, this function\n may return NULL if the data loaded from flash is not valid.\n\n @note Call esp_phy_release_init_data to release the pointer obtained using\n this function after the call to esp_wifi_init.\n\n @return pointer to PHY init data structure"]
    pub fn esp_phy_get_init_data() -> *const esp_phy_init_data_t;
}
extern "C" {
    #[doc = " @brief Release PHY init data\n @param data  pointer to PHY init data structure obtained from\n              esp_phy_get_init_data function"]
    pub fn esp_phy_release_init_data(data: *const esp_phy_init_data_t);
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_init to load PHY calibration data\n\n This is a convenience function which can be used to load PHY calibration\n data from NVS. Data can be stored to NVS using esp_phy_store_cal_data_to_nvs\n function.\n\n If calibration data is not present in the NVS, or\n data is not valid (was obtained for a chip with a different MAC address,\n or obtained for a different version of software), this function will\n return an error.\n\n If \"Initialize PHY in startup code\" option is set in menuconfig, this\n function will be used to load calibration data. To provide a different\n mechanism for loading calibration data, disable\n \"Initialize PHY in startup code\" option in menuconfig and call esp_phy_init\n function from the application. For an example usage of esp_phy_init and\n this function, see esp_phy_store_cal_data_to_nvs function in cpu_start.c\n\n @param out_cal_data pointer to calibration data structure to be filled with\n                     loaded data.\n @return ESP_OK on success"]
    pub fn esp_phy_load_cal_data_from_nvs(
        out_cal_data: *mut esp_phy_calibration_data_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Function called by esp_phy_init to store PHY calibration data\n\n This is a convenience function which can be used to store PHY calibration\n data to the NVS. Calibration data is returned by esp_phy_init function.\n Data saved using this function to the NVS can later be loaded using\n esp_phy_store_cal_data_to_nvs function.\n\n If \"Initialize PHY in startup code\" option is set in menuconfig, this\n function will be used to store calibration data. To provide a different\n mechanism for storing calibration data, disable\n \"Initialize PHY in startup code\" option in menuconfig and call esp_phy_init\n function from the application.\n\n @param cal_data pointer to calibration data which has to be saved.\n @return ESP_OK on success"]
    pub fn esp_phy_store_cal_data_to_nvs(cal_data: *const esp_phy_calibration_data_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Erase PHY calibration data which is stored in the NVS\n\n This is a function which can be used to trigger full calibration as a last-resort remedy\n if partial calibration is used. It can be called in the application based on some conditions\n (e.g. an option provided in some diagnostic mode).\n\n @return ESP_OK on success\n @return others on fail. Please refer to NVS API return value error number."]
    pub fn esp_phy_erase_cal_data_in_nvs() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable PHY and RF module\n\n PHY and RF module should be enabled in order to use WiFi or BT.\n Now PHY and RF enabling job is done automatically when start WiFi or BT. Users should not\n call this API in their application.\n"]
    pub fn esp_phy_enable();
}
extern "C" {
    #[doc = " @brief Disable PHY and RF module\n\n PHY module should be disabled in order to shutdown WiFi or BT.\n Now PHY and RF disabling job is done automatically when stop WiFi or BT. Users should not\n call this API in their application.\n"]
    pub fn esp_phy_disable();
}
extern "C" {
    #[doc = " @brief Enable BTBB module\n\n BTBB module should be enabled in order to use IEEE802154 or BT.\n Now BTBB enabling job is done automatically when start IEEE802154 or BT. Users should not\n call this API in their application.\n"]
    pub fn esp_btbb_enable();
}
extern "C" {
    #[doc = " @brief Disable BTBB module\n\n Dsiable BTBB module, used by IEEE802154 or Bluetooth.\n Users should not call this API in their application.\n"]
    pub fn esp_btbb_disable();
}
extern "C" {
    #[doc = " @brief Load calibration data from NVS and initialize PHY and RF module"]
    pub fn esp_phy_load_cal_and_init();
}
extern "C" {
    #[doc = " @brief Initialize backup memory for Phy power up/down"]
    pub fn esp_phy_modem_init();
}
extern "C" {
    #[doc = " @brief Deinitialize backup memory for Phy power up/down\n Set phy_init_flag if all modems deinit on ESP32C3"]
    pub fn esp_phy_modem_deinit();
}
extern "C" {
    #[doc = " @brief Enable WiFi/BT common clock\n"]
    pub fn esp_phy_common_clock_enable();
}
extern "C" {
    #[doc = " @brief Disable WiFi/BT common clock\n"]
    pub fn esp_phy_common_clock_disable();
}
extern "C" {
    #[doc = " @brief            Get the time stamp when PHY/RF was switched on\n @return           return 0 if PHY/RF is never switched on. Otherwise return time in\n                   microsecond since boot when phy/rf was last switched on"]
    pub fn esp_phy_rf_get_on_ts() -> i64;
}
extern "C" {
    #[doc = " @brief Update the corresponding PHY init type according to the country code of Wi-Fi.\n\n @param country country code\n @return ESP_OK on success.\n @return esp_err_t code describing the error on fail"]
    pub fn esp_phy_update_country_info(country: *const crate::binary::c_types::c_char)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get PHY lib version\n @return PHY lib version."]
    pub fn get_phy_version_str() -> *mut crate::binary::c_types::c_char;
}
pub const phy_i2c_master_command_type_t_PHY_I2C_MST_CMD_TYPE_OFF: phy_i2c_master_command_type_t = 0;
pub const phy_i2c_master_command_type_t_PHY_I2C_MST_CMD_TYPE_ON: phy_i2c_master_command_type_t = 1;
pub const phy_i2c_master_command_type_t_PHY_I2C_MST_CMD_TYPE_MAX: phy_i2c_master_command_type_t = 2;
pub type phy_i2c_master_command_type_t = crate::binary::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t {
    pub config: [phy_i2c_master_command_attribute_t__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_i2c_master_command_attribute_t__bindgen_ty_1 {
    pub start: u8,
    pub end: u8,
    pub host_id: u8,
}
extern "C" {
    #[doc = " @brief Return ROM function pointer table from PHY library."]
    pub fn phy_get_romfunc_addr();
}
extern "C" {
    #[doc = " @brief Initialize PHY module and do RF calibration\n @param[in] init_data Initialization parameters to be used by the PHY\n @param[inout] cal_data As input, calibration data previously obtained. As output, will contain new calibration data.\n @param[in] cal_mode  RF calibration mode\n @return ESP_CAL_DATA_CHECK_FAIL if calibration data checksum fails, other values are reserved for future use"]
    pub fn register_chipv7_phy(
        init_data: *const esp_phy_init_data_t,
        cal_data: *mut esp_phy_calibration_data_t,
        cal_mode: esp_phy_calibration_mode_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    #[doc = " @brief Get the format version of calibration data used by PHY library.\n @return Format version number, OR'ed with BIT(16) if PHY is in WIFI only mode."]
    pub fn phy_get_rf_cal_version() -> u32;
}
extern "C" {
    #[doc = " @brief Set RF/BB for only WIFI mode or coexist(WIFI & BT) mode\n @param[in] true is for only WIFI mode, false is for coexist mode. default is 0.\n @return NULL"]
    pub fn phy_set_wifi_mode_only(wifi_only: bool);
}
extern "C" {
    #[doc = " @brief Set BT the highest priority in coexist mode.\n @return NULL"]
    pub fn coex_bt_high_prio();
}
extern "C" {
    #[doc = " @brief Open PHY and RF."]
    pub fn phy_wakeup_init();
}
extern "C" {
    #[doc = " @brief Shutdown PHY and RF."]
    pub fn phy_close_rf();
}
extern "C" {
    #[doc = " @brief Disable PHY temperature sensor."]
    pub fn phy_xpd_tsens();
}
extern "C" {
    #[doc = " @brief Get the configuration info of PHY i2c master command memory.\n\n @param   attr the configuration info of PHY i2c master command memory"]
    pub fn phy_i2c_master_mem_cfg(attr: *mut phy_i2c_master_command_attribute_t);
}
extern "C" {
    #[doc = " @brief Store and load PHY digital registers.\n\n @param     backup_en  if backup_en is true, store PHY digital registers to memory. Otherwise load PHY digital registers from memory\n @param     mem_addr   Memory address to store and load PHY digital registers\n\n @return    memory size"]
    pub fn phy_dig_reg_backup(backup_en: bool, mem_addr: *mut u32) -> u8;
}
#[doc = "< Prefer to WiFi, WiFi will have more opportunity to use RF"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_WIFI: esp_coex_prefer_t = 0;
#[doc = "< Prefer to bluetooth, bluetooth will have more opportunity to use RF"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_BT: esp_coex_prefer_t = 1;
#[doc = "< Do balance of WiFi and bluetooth"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_BALANCE: esp_coex_prefer_t = 2;
#[doc = "< Prefer value numbers"]
pub const esp_coex_prefer_t_ESP_COEX_PREFER_NUM: esp_coex_prefer_t = 3;
#[doc = " @brief coex prefer value"]
pub type esp_coex_prefer_t = crate::binary::c_types::c_uint;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_1: external_coex_wire_t = 0;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_2: external_coex_wire_t = 1;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_3: external_coex_wire_t = 2;
pub const external_coex_wire_t_EXTERN_COEX_WIRE_NUM: external_coex_wire_t = 3;
pub type external_coex_wire_t = crate::binary::c_types::c_uint;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_WIFI: esp_coex_status_type_t = 0;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_BLE: esp_coex_status_type_t = 1;
pub const esp_coex_status_type_t_ESP_COEX_ST_TYPE_BT: esp_coex_status_type_t = 2;
#[doc = " @brief coex status type"]
pub type esp_coex_status_type_t = crate::binary::c_types::c_uint;
extern "C" {
    #[doc = " @brief Get software coexist version string\n\n @return : version string"]
    pub fn esp_coex_version_get() -> *const crate::binary::c_types::c_char;
}
extern "C" {
    #[doc = " @deprecated Use esp_coex_status_bit_set() and esp_coex_status_bit_clear() instead.\n  Set coexist preference of performance\n  For example, if prefer to bluetooth, then it will make A2DP(play audio via classic bt)\n  more smooth while wifi is runnning something.\n  If prefer to wifi, it will do similar things as prefer to bluetooth.\n  Default, it prefer to balance.\n\n  @param prefer : the prefer enumeration value\n  @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_preference_set(prefer: esp_coex_prefer_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set coex schm status\n @param type : WIFI/BLE/BT\n @param status : WIFI/BLE/BT STATUS\n @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_status_bit_set(type_: esp_coex_status_type_t, status: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear coex schm status\n @param type : WIFI/BLE/BT\n @param status : WIFI/BLE/BT STATUS\n @return : ESP_OK - success, other - failed"]
    pub fn esp_coex_status_bit_clear(type_: esp_coex_status_type_t, status: u32) -> esp_err_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct coex_adapter_funcs_t {
    pub _version: i32,
    pub _task_yield_from_isr: ::core::option::Option<unsafe extern "C" fn()>,
    pub _semphr_create: ::core::option::Option<
        unsafe extern "C" fn(max: u32, init: u32) -> *mut crate::binary::c_types::c_void,
    >,
    pub _semphr_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::binary::c_types::c_void)>,
    pub _semphr_take_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            semphr: *mut crate::binary::c_types::c_void,
            hptw: *mut crate::binary::c_types::c_void,
        ) -> i32,
    >,
    pub _semphr_give_from_isr: ::core::option::Option<
        unsafe extern "C" fn(
            semphr: *mut crate::binary::c_types::c_void,
            hptw: *mut crate::binary::c_types::c_void,
        ) -> i32,
    >,
    pub _semphr_take: ::core::option::Option<
        unsafe extern "C" fn(
            semphr: *mut crate::binary::c_types::c_void,
            block_time_tick: u32,
        ) -> i32,
    >,
    pub _semphr_give: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::binary::c_types::c_void) -> i32,
    >,
    pub _is_in_isr: ::core::option::Option<unsafe extern "C" fn() -> crate::binary::c_types::c_int>,
    pub _malloc_internal: ::core::option::Option<
        unsafe extern "C" fn(size: usize) -> *mut crate::binary::c_types::c_void,
    >,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut crate::binary::c_types::c_void)>,
    pub _esp_timer_get_time: ::core::option::Option<unsafe extern "C" fn() -> i64>,
    pub _env_is_chip: ::core::option::Option<unsafe extern "C" fn() -> bool>,
    pub _timer_disarm:
        ::core::option::Option<unsafe extern "C" fn(timer: *mut crate::binary::c_types::c_void)>,
    pub _timer_done:
        ::core::option::Option<unsafe extern "C" fn(ptimer: *mut crate::binary::c_types::c_void)>,
    pub _timer_setfn: ::core::option::Option<
        unsafe extern "C" fn(
            ptimer: *mut crate::binary::c_types::c_void,
            pfunction: *mut crate::binary::c_types::c_void,
            parg: *mut crate::binary::c_types::c_void,
        ),
    >,
    pub _timer_arm_us: ::core::option::Option<
        unsafe extern "C" fn(ptimer: *mut crate::binary::c_types::c_void, us: u32, repeat: bool),
    >,
    pub _magic: i32,
}
extern "C" {
    pub static mut g_coex_adapter_funcs: coex_adapter_funcs_t;
}
pub const ieee802154_coex_event_t_IEEE802154_HIGH: ieee802154_coex_event_t = 1;
pub const ieee802154_coex_event_t_IEEE802154_MIDDLE: ieee802154_coex_event_t = 2;
pub const ieee802154_coex_event_t_IEEE802154_LOW: ieee802154_coex_event_t = 3;
pub const ieee802154_coex_event_t_IEEE802154_IDLE: ieee802154_coex_event_t = 4;
pub const ieee802154_coex_event_t_IEEE802154_EVENT_MAX: ieee802154_coex_event_t = 5;
pub type ieee802154_coex_event_t = crate::binary::c_types::c_uint;
extern "C" {
    pub fn esp_coex_ieee802154_txrx_pti_set(event: ieee802154_coex_event_t);
}
extern "C" {
    pub fn esp_coex_ieee802154_ack_pti_set(event: ieee802154_coex_event_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: crate::binary::c_types::c_uint,
    pub fp_offset: crate::binary::c_types::c_uint,
    pub overflow_arg_area: *mut crate::binary::c_types::c_void,
    pub reg_save_area: *mut crate::binary::c_types::c_void,
}
